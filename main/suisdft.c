/* Copyright (c) Wayne Mogg, 2017.*/
/* All rights reserved.                       */

#include "su.h"
#include "segy.h"
#include "header.h"
#include "sux.h"

/*********************** self documentation **********************/
char *sdoc[] = {
"                                                                   ",
" SUISDFT -  Inverse sliding discrete fourier tranform. Take time-  ",
"            frequency representation generated by SUSDFT and invert",
"            it back to seismic data.                               ",
"                                                                   ",
" suisdct <stdin >sdout                                             ",
"                                                                   ",
" Required parameters:                                              ",
" dt=(from header)  time sampling interval (sec)                    ",
" nwin=             number of frequency traces per time-frequency   ",
"                   gather                                          ",
"                                                                   ",
" Optional parameters:                                              ",
" verbose=0         no advisory messages                            ",
"         1         for advisory messages                           ",
"                                                                   ",
" This process inverts a time-frequency representation of seismic   ",
" data generated by the sliding discrete fourier transform (SUSDFT).",
"                                                                   ",
" Examples:                                                         ",
"   suvibro | susdft nwin=31 | suisdft nwin=31 | suximage                           ",
"                                                                   ",
NULL};

/* Author: Wayne Mogg, Apr 2017
 *
 * Trace header fields accessed: ns,dt, trid, ntr
 * Trace header fields modified: tracl, tracr, d1, f2, d2, trid, ntr
 */
/**************** end self doc ***********************************/


segy tr;

int
main(int argc, char **argv)
{
    float dt;
    int nwin;
    int verbose;

    int nt;
    int tracr=0;
    
    int ntrc;
    int nf;
    int j;
    complex** specbuff;
    hSDFT dftHandle;
 	
/* Initialize */
	initargs(argc, argv);
	requestdoc(1);

/* Get info from first trace */ 
    if (!gettr(&tr))  err("can't get first trace");
    nt = tr.ns/2;
    if (!getparfloat("dt", &dt))	dt = ((double) tr.dt)/1000000.0;
    if (!dt) err("dt field is zero and not getparred");
    if (tr.trid != FUNPACKNYQ) err("expecting complex trace but got trcid=%d", tr.trid);
    
/* Get parameters */
    if (!getparint("verbose", &verbose)) verbose=0;
    if (!getparint("nwin", &nwin)) err("nwin must be specified");
    if (nwin%2==0) {
        nwin++;
        if (verbose)
            warn("adjusting nwin to be odd, was %d now %d",nwin-1, nwin);
    }
    
/* Set up DCT parameters and workspaces */
    nf = nwin/2+1;
    dftHandle = SDFT_init( nwin, nt );
    specbuff = ealloc2complex(nt, nf );
    ntrc = 0;
    tracr = 0;
/* Main processing loop */
    do {
        for (j=0; j<nt; j++)
            specbuff[ntrc][j] = cmplx(tr.data[2*j],tr.data[2*j+1]);
        if (ntrc == nf-1) {
            ISDFT( dftHandle, specbuff, tr.data );
            tr.ns = nt;
            tr.tracr = ++tracr;
            tr.trid = TREAL;
            tr.f1 = 0.0f;
            tr.d2 = 0.0f;
            puttr(&tr);
            ntrc = 0;
        } else
            ntrc++;
    } while (gettr(&tr));
                
    free2complex( specbuff );
    SDFT_free( dftHandle );

    return (CWP_Exit());
}
